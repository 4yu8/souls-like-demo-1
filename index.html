<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<title>Soulslike Three.js</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;font-family:sans-serif}
#hud{position:fixed;top:10px;left:10px;color:#fff;z-index:10}
.bar{width:200px;height:12px;background:#333;margin-bottom:6px}
.fill{height:100%;background:#0f0}
#stamina .fill{background:#ff0}
#mana .fill{background:#0ff}
#compass{margin-top:10px}
#center{position:fixed;top:50%;left:50%;width:10px;height:10px;margin:-5px;background:#fff;border-radius:50%}
</style>
</head>
<body>
<div id="hud">
<div id="health" class="bar"><div class="fill"></div></div>
<div id="stamina" class="bar"><div class="fill"></div></div>
<div id="mana" class="bar"><div class="fill"></div></div>
<div id="compass">N</div>
</div>
<div id="center"></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x000000,50,300);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled=true;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

const hemi=new THREE.HemisphereLight(0x8888ff,0x222200,0.5);
scene.add(hemi);
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(50,100,0);
sun.castShadow=true;
scene.add(sun);

let timeOfDay=0;

const terrainSize=200;
const terrainGeo=new THREE.PlaneGeometry(terrainSize,terrainSize,64,64);
terrainGeo.rotateX(-Math.PI/2);
const verts=terrainGeo.attributes.position;
for(let i=0;i<verts.count;i++){
const x=verts.getX(i),z=verts.getZ(i);
const h=Math.sin(x*0.1)*2+Math.cos(z*0.1)*2+Math.random();
verts.setY(i,h);
}
verts.needsUpdate=true;
terrainGeo.computeVertexNormals();
const terrain=new THREE.Mesh(terrainGeo,new THREE.MeshStandardMaterial({color:0x224422}));
terrain.receiveShadow=true;
scene.add(terrain);

const player={
obj:new THREE.Mesh(new THREE.CapsuleGeometry(0.5,1.2,4,8),new THREE.MeshStandardMaterial({color:0x888888})),
vel:new THREE.Vector3(),
health:100,stamina:100,mana:50,
invul:0,grounded:false
};
player.obj.castShadow=true;
scene.add(player.obj);

camera.position.set(0,3,5);

const enemies=[];
function spawnEnemy(x,z,boss=false){
const geo=boss?new THREE.SphereGeometry(2,16,16):new THREE.SphereGeometry(1,12,12);
const mat=new THREE.MeshStandardMaterial({color:boss?0x880000:0x884400});
const m=new THREE.Mesh(geo,mat);
m.position.set(x,2,z);
m.castShadow=true;
scene.add(m);
enemies.push({obj:m,health:boss?300:50,aggro:false,boss,phase:1,cd:0});
}
for(let i=0;i<10;i++)spawnEnemy((Math.random()-0.5)*100,(Math.random()-0.5)*100,false);
spawnEnemy(0,-50,true);

let lockTarget=null;

const keys={};
window.addEventListener('keydown',e=>keys[e.code]=true);
window.addEventListener('keyup',e=>keys[e.code]=false);
window.addEventListener('click',()=>renderer.domElement.requestPointerLock());
let yaw=0,pitch=0;
window.addEventListener('mousemove',e=>{
if(document.pointerLockElement){
yaw-=e.movementX*0.002;
pitch-=e.movementY*0.002;
pitch=Math.max(-1.2,Math.min(1.2,pitch));
}
});

const audioCtx=new AudioContext();
function beep(freq,dur){
const o=audioCtx.createOscillator();
const g=audioCtx.createGain();
o.frequency.value=freq;
o.connect(g);g.connect(audioCtx.destination);
o.start();
g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+dur);
o.stop(audioCtx.currentTime+dur);
}

function updatePlayer(dt){
const dir=new THREE.Vector3();
if(keys.KeyW)dir.z-=1;
if(keys.KeyS)dir.z+=1;
if(keys.KeyA)dir.x-=1;
if(keys.KeyD)dir.x+=1;
dir.normalize().applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
const speed=keys.ShiftLeft?8:4;
if(dir.length()&&player.stamina>0){
player.vel.x=dir.x*speed;
player.vel.z=dir.z*speed;
player.stamina-=dt*10;
}else{
player.vel.x*=0.9;
player.vel.z*=0.9;
}
if(keys.Space&&player.grounded){
player.vel.y=6;
player.grounded=false;
beep(200,0.1);
}
player.vel.y-=9.8*dt;
player.obj.position.addScaledVector(player.vel,dt);
if(player.obj.position.y<1){
player.obj.position.y=1;
player.vel.y=0;
player.grounded=true;
}
if(player.invul>0)player.invul-=dt;
player.stamina=Math.min(100,player.stamina+dt*5);
}

function updateEnemies(dt){
for(const e of enemies){
if(e.health<=0){scene.remove(e.obj);continue;}
const d=e.obj.position.distanceTo(player.obj.position);
if(d<20)e.aggro=true;
if(e.aggro){
const dir=player.obj.position.clone().sub(e.obj.position).normalize();
if(d>2){
e.obj.position.addScaledVector(dir,dt*(e.boss?2:3));
}else if(e.cd<=0){
if(player.invul<=0){
player.health-=e.boss?20:10;
player.invul=1;
beep(80,0.2);
}
e.cd=2;
}
if(e.boss&&e.health<150)e.phase=2;
}
e.cd=Math.max(0,e.cd-dt);
}
}

function attack(){
for(const e of enemies){
if(e.health>0&&e.obj.position.distanceTo(player.obj.position)<2){
e.health-=20;
beep(400,0.1);
}
}
}
window.addEventListener('mousedown',e=>{if(e.button===0)attack();if(e.button===2){
lockTarget=enemies.find(en=>en.health>0);
}});

function updateCamera(){
let target=player.obj.position.clone();
if(lockTarget&&lockTarget.health>0)target=lockTarget.obj.position;
const camDir=new THREE.Vector3(Math.sin(yaw)*Math.cos(pitch),Math.sin(pitch),Math.cos(yaw)*Math.cos(pitch));
camera.position.copy(player.obj.position).addScaledVector(camDir,-5).add(new THREE.Vector3(0,3,0));
camera.lookAt(target);
}

function updateUI(){
document.querySelector('#health .fill').style.width=player.health+'%';
document.querySelector('#stamina .fill').style.width=player.stamina+'%';
document.querySelector('#mana .fill').style.width=player.mana*2+'%';
}

let last=performance.now();
function loop(t){
const dt=(t-last)/1000;last=t;
timeOfDay+=dt*0.05;
sun.position.set(Math.sin(timeOfDay)*100,Math.cos(timeOfDay)*100,0);
sun.intensity=Math.max(0.2,Math.cos(timeOfDay));
updatePlayer(dt);
updateEnemies(dt);
updateCamera();
updateUI();
renderer.render(scene,camera);
requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>

</body>
</html>
