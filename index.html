<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<title>Procedural Souls-Like Demo</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;font-family:sans-serif}
#hud{position:absolute;top:10px;left:10px;color:#fff;font-size:14px}
.bar{width:200px;height:10px;background:#333;margin-bottom:4px}
.fill{height:100%}
#health .fill{background:#c33}
#stamina .fill{background:#3c3}
</style>
</head>
<body>
<div id="hud">
  <div id="health" class="bar"><div class="fill"></div></div>
  <div id="stamina" class="bar"><div class="fill"></div></div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";

//////////////////// SETUP ////////////////////
const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x88aacc,50,300);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,500);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled=true;
document.body.appendChild(renderer.domElement);

window.addEventListener("resize",()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
});

//////////////////// LIGHT ////////////////////
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(50,100,50);
sun.castShadow=true;
scene.add(sun);
scene.add(new THREE.AmbientLight(0x404040));

//////////////////// PROCEDURAL TEXTURES ////////////////////
function makeTexture(c1,c2){
 const c=document.createElement("canvas");
 c.width=c.height=64;
 const ctx=c.getContext("2d");
 const g=ctx.createLinearGradient(0,0,64,64);
 g.addColorStop(0,c1);
 g.addColorStop(1,c2);
 ctx.fillStyle=g;
 ctx.fillRect(0,0,64,64);
 return new THREE.CanvasTexture(c);
}

//////////////////// TERRAIN ////////////////////
const size=300,res=128;
const terrainGeo=new THREE.PlaneGeometry(size,size,res,res);
terrainGeo.rotateX(-Math.PI/2);
const p=terrainGeo.attributes.position;
for(let i=0;i<p.count;i++){
 const x=p.getX(i),z=p.getZ(i);
 const h=Math.sin(x*0.05)*Math.cos(z*0.05)*5+
         Math.sin(x*0.15+z*0.1)*2;
 p.setY(i,h);
}
p.needsUpdate=true;
terrainGeo.computeVertexNormals();
const terrain=new THREE.Mesh(
 terrainGeo,
 new THREE.MeshStandardMaterial({map:makeTexture("#355533","#223322")})
);
terrain.receiveShadow=true;
scene.add(terrain);

//////////////////// WATER ////////////////////
const water=new THREE.Mesh(
 new THREE.PlaneGeometry(size,size),
 new THREE.MeshStandardMaterial({color:0x224466,transparent:true,opacity:0.6})
);
water.rotation.x=-Math.PI/2;
water.position.y=-2;
scene.add(water);

//////////////////// TREES ////////////////////
function makeTree(x,z){
 const trunk=new THREE.Mesh(
  new THREE.CylinderGeometry(0.3,0.5,4),
  new THREE.MeshStandardMaterial({color:0x664422})
 );
 const top=new THREE.Mesh(
  new THREE.ConeGeometry(2,5,8),
  new THREE.MeshStandardMaterial({color:0x226622})
 );
 trunk.position.set(x,2,z);
 top.position.set(x,6,z);
 trunk.castShadow=top.castShadow=true;
 scene.add(trunk,top);
}
for(let i=0;i<120;i++){
 makeTree(
  (Math.random()-0.5)*size,
  (Math.random()-0.5)*size
 );
}

//////////////////// PLAYER ////////////////////
const playerTex=makeTexture("#cccccc","#777777");
const player=new THREE.Mesh(
 new THREE.CapsuleGeometry(0.5,1.2,4,8),
 new THREE.MeshStandardMaterial({map:playerTex})
);
player.position.set(0,5,0);
player.castShadow=true;
scene.add(player);

const sword=new THREE.Mesh(
 new THREE.BoxGeometry(0.1,1.5,0.2),
 new THREE.MeshStandardMaterial({color:0xdddddd})
);
sword.position.set(0.6,1,0);
player.add(sword);

const stats={health:100,stamina:100,inv:0};
const vel=new THREE.Vector3();

//////////////////// ENEMIES ////////////////////
const enemies=[];
function spawnEnemy(){
 const tex=makeTexture("#883333","#552222");
 const e=new THREE.Mesh(
  new THREE.BoxGeometry(1.2,2,1.2),
  new THREE.MeshStandardMaterial({map:tex})
 );
 const a=Math.random()*Math.PI*2;
 const d=15+Math.random()*10;
 e.position.set(
  player.position.x+Math.cos(a)*d,
  5,
  player.position.z+Math.sin(a)*d
 );
 e.castShadow=true;
 e.userData={health:40};
 scene.add(e);
 enemies.push(e);
}

//////////////////// INPUT ////////////////////
const keys={};
addEventListener("keydown",e=>keys[e.code]=true);
addEventListener("keyup",e=>keys[e.code]=false);

let yaw=0,pitch=0;
addEventListener("mousemove",e=>{
 if(document.pointerLockElement){
  yaw-=e.movementX*0.002;
  pitch=Math.max(-1,Math.min(0.4,pitch-e.movementY*0.002));
 }
});
renderer.domElement.onclick=()=>renderer.domElement.requestPointerLock();

//////////////////// LOOP ////////////////////
const clock=new THREE.Clock();
function updateHUD(){
 document.querySelector("#health .fill").style.width=stats.health+"%";
 document.querySelector("#stamina .fill").style.width=stats.stamina+"%";
}

function animate(){
 requestAnimationFrame(animate);
 const dt=clock.getDelta();

 ////// PLAYER MOVE
 let speed=keys["ShiftLeft"]?8:4;
 if(keys["ShiftLeft"]) stats.stamina-=20*dt;
 if(stats.stamina<0){speed=4;stats.stamina=0;}

 const dir=new THREE.Vector3(
  (keys["KeyA"]?-1:0)+(keys["KeyD"]?1:0),
  0,
  (keys["KeyW"]?-1:0)+(keys["KeyS"]?1:0)
 ).normalize().applyAxisAngle(new THREE.Vector3(0,1,0),yaw);

 vel.x=dir.x*speed;
 vel.z=dir.z*speed;
 vel.y-=25*dt;

 player.position.addScaledVector(vel,dt);
 if(player.position.y<2){
  player.position.y=2;
  vel.y=0;
 }

 stats.stamina=Math.min(100,stats.stamina+15*dt);
 if(stats.inv>0) stats.inv-=dt;

 ////// ATTACK
 if(keys["Mouse0"]&&stats.stamina>20){
  keys["Mouse0"]=false;
  stats.stamina-=20;
  enemies.forEach(e=>{
   if(e.position.distanceTo(player.position)<2){
    e.userData.health-=20;
   }
  });
 }

 ////// ENEMY LOGIC
 for(let i=enemies.length-1;i>=0;i--){
  const e=enemies[i];
  if(e.userData.health<=0){
   scene.remove(e);
   enemies.splice(i,1);
   continue;
  }
  const v=player.position.clone().sub(e.position).normalize();
  e.position.addScaledVector(v,2*dt);
  if(e.position.distanceTo(player.position)<1.5&&stats.inv<=0){
   stats.health-=10;
   stats.inv=0.8;
  }
 }

 ////// SPAWN CONTROL
 while(enemies.length<4) spawnEnemy();

 ////// CAMERA
 const off=new THREE.Vector3(0,4,7);
 off.applyAxisAngle(new THREE.Vector3(1,0,0),pitch);
 off.applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
 camera.position.copy(player.position).add(off);
 camera.lookAt(player.position.clone().add(new THREE.Vector3(0,1,0)));

 updateHUD();
 renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
